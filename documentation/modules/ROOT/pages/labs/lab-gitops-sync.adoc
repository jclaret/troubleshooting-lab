= GitOps Operator - Sync Flows
include::../_attributes.adoc[]

[[gitos]]
== Lab Overview

This lab focuses specifically on ArgoCD deployment scenarios and synchronization analysis. You'll learn essential techniques for tracking git commits processed by ArgoCD, analyzing sync patterns, examining sync history, and troubleshooting sync failures with detailed error analysis.

=== Learning Objectives

By completing this lab, you will be able to:

* Check latest commits that ArgoCD has processed from Git repositories
* Determine if application syncs are performed manually or automatically
* Analyze ArgoCD application sync history and patterns
* Map ArgoCD sync operations to specific Git commits
* Investigate and resolve sync errors with detailed error message analysis
* Troubleshoot applications in degraded state and identify unhealthy resources

== Exercise 1: Tracking Latest Commits Processed by ArgoCD

=== Understanding ArgoCD Git Commit Processing

ArgoCD continuously monitors Git repositories and processes commits based on configured policies. Understanding what commits have been processed is crucial for deployment tracking.

=== Checking Latest Commits ArgoCD Has Processed

Examine the current revision and commit information processed by ArgoCD:

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
# Check current revision synced by ArgoCD for all applications
oc get applications.argoproj.io -n openshift-gitops 

# Get detailed commit information for a specific application
APP_NAME="<application-name>"
APP_NS="<argocd-namespace>"

# Extract current synced revision (commit hash)
CURRENT_REVISION=$(oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.status.sync.revision}')
echo "Current synced revision: $CURRENT_REVISION"

# Get commit details including timestamp and author
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.status.sync}' | jq '.'

# Check if there are newer commits available (target vs current revision)
TARGET_REVISION=$(oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.status.operationState.sync.revision}')
echo "Target revision: $TARGET_REVISION"
echo "Current revision: $CURRENT_REVISION"

if [ "$TARGET_REVISION" != "$CURRENT_REVISION" ]; then
    echo "‚ö†Ô∏è  Application has newer commits available for sync"
else
    echo "‚úÖ Application is synced to latest commit"
fi
----

== Exercise 2: Determining Manual vs Automatic Sync Configuration

=== Understanding ArgoCD Sync Policies

ArgoCD applications can be configured for automatic or manual synchronization. Identifying the sync policy helps understand deployment patterns.

=== Checking Sync Policy Configuration

Determine if applications are configured for manual or automatic synchronization:

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
# Check sync policy for all applications
oc get applications.argoproj.io -A -o custom-columns="NAME:.metadata.name,NAMESPACE:.metadata.namespace,AUTO_SYNC:.spec.syncPolicy.automated" --sort-by=.metadata.name

# Detailed sync policy analysis for specific application
APP_NAME="<application-name>"
APP_NS="<argocd-namespace>"

# Check if automated sync is enabled
AUTO_SYNC=$(oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.spec.syncPolicy.automated}')
if [ "$AUTO_SYNC" != "null" ] && [ -n "$AUTO_SYNC" ]; then
    echo "‚úÖ Application '$APP_NAME' has AUTOMATIC sync enabled"
    
    # Check automated sync options
    PRUNE=$(oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.spec.syncPolicy.automated.prune}')
    SELF_HEAL=$(oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.spec.syncPolicy.automated.selfHeal}')
    
    echo "  - Prune enabled: $PRUNE"
    echo "  - Self-heal enabled: $SELF_HEAL"
else
    echo "‚ö†Ô∏è  Application '$APP_NAME' has MANUAL sync only"
fi
----

== Exercise 3: ArgoCD Application Sync History Analysis

=== Understanding Sync History Importance

ArgoCD maintains detailed history of all sync operations, enabling you to track deployment patterns, investigate failures, and understand application evolution over time.

=== Examining Application Sync History

Use OpenShift commands to analyze sync history:

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
# Get historical sync information from application status
APP_NAME="<application-name>"
APP_NS="<argocd-namespace>"

# Count total number of syncs performed
SYNC_COUNT=$(oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.status.history[*]}' | jq -s '. | length')
echo "Total sync operations: $SYNC_COUNT"

# Extract sync history with timestamps
echo "=== Sync History Analysis ==="
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq -r '.status.history[] | "Sync ID: \(.id) | Deployed: \(.deployedAt) | Revision: \(.revision) | Source: \(.source.repoURL)"'

# Identify most recent syncs (last 5)
echo "=== Recent Sync Operations ==="
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq -r '.status.history[-5:] | reverse[] | "[\(.deployedAt)] Revision: \(.revision[0:8]) | Source: \(.source.path // "root")"'
----

== Exercise 4: Mapping ArgoCD Syncs to Specific Git Commits

=== Understanding Commit-to-Deployment Mapping

Mapping ArgoCD sync operations to specific Git commits is crucial for tracking which code changes have been deployed and understanding the relationship between source code and running applications.

=== Basic Commit-to-Sync Mapping

Create basic mapping between Git commits and ArgoCD deployments:

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
APP_NAME="<application-name>"
APP_NS="<argocd-namespace>"

# Get repository and revision information
REPO_URL=$(oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.spec.source.repoURL}')
CURRENT_REVISION=$(oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.status.sync.revision}')

echo "Repository: $REPO_URL"
echo "Current Deployed Commit: $CURRENT_REVISION"

# Show recent deployment history (last 5)
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq -r '
  .status.history[-5:] | reverse[] | 
  "[\(.deployedAt)] Commit: \(.revision[0:12])"'

# Check current sync and health status
SYNC_STATUS=$(oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.status.sync.status}')
HEALTH_STATUS=$(oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.status.health.status}')

echo "Current Status: Sync=$SYNC_STATUS, Health=$HEALTH_STATUS"
----

[TIP]
====
üí° For comprehensive Git-to-ArgoCD correlation analysis, use the automated script provided in link:gitops-scripts.html[GitOps Scripts Documentation].
====

== Exercise 5: Sync Error Analysis and Troubleshooting

=== Understanding ArgoCD Sync Errors

Sync errors in ArgoCD can occur due to various reasons including resource conflicts, permission issues, invalid manifests, or Git repository problems. Understanding error patterns is crucial for effective troubleshooting.

=== Basic Sync Error Investigation

Use these essential commands to identify and investigate sync errors:

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
# Identify applications with sync errors
oc get applications.argoproj.io -A -o custom-columns="NAME:.metadata.name,NAMESPACE:.metadata.namespace,SYNC:.status.sync.status,HEALTH:.status.health.status" | grep -v Synced

# Basic error analysis for specific application
APP_NAME="<application-name>"
APP_NS="<argocd-namespace>"

# Check sync status and basic conditions
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.status.sync.status}'
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.status.health.status}'

# View error conditions
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq '.status.conditions[]? | select(.type == "ComparisonError" or .type == "SyncError")'

# Check recent operation status
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq '.status.operationState | {phase, message, startedAt, finishedAt}'
----

=== Out-of-Sync Resource Analysis

Check which specific resources are causing sync issues:

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
# List out-of-sync resources
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq -r '
  .status.resources[]? |
  select(.status != "Synced") |
  "üîÑ \(.kind)/\(.name) in \(.namespace // "default"): \(.status)"'

# Check for hook execution errors
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq -r '
  .status.operationState.sync.resources[]? |
  select(.hookType != null and .status == "Failed") |
  "ü™ù Hook: \(.hookType) - \(.kind)/\(.name): \(.message)"'

# Basic comparison error check
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.status.conditions[?(@.type=="ComparisonError")].message}'
----

=== Manual Sync Actions

Basic commands for resolving sync issues:

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
# Manual sync
argocd app sync $APP_NAME

# Hard refresh (re-examine Git repository)
argocd app get $APP_NAME --hard-refresh

# Force replace resources (for immutable field changes)
argocd app sync $APP_NAME --replace

# Check ArgoCD component logs
oc logs -n openshift-gitops deployment/openshift-gitops-server --tail=50
oc logs -n openshift-gitops statefulset/openshift-gitops-application-controller --tail=50
----

=== Common Sync Error Categories

Common sync error patterns and their basic troubleshooting approaches:

**Permission Errors:**
```bash
# Check for permission-related error messages
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq '.status.conditions[]? | select(.message | test("permission|forbidden|unauthorized"; "i"))'
```

**Resource Conflicts:**
```bash
# Check for conflict errors
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq '.status.conditions[]? | select(.message | test("conflict|already exists"; "i"))'
```

**Git Repository Issues:**
```bash
# Check for Git-related errors
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq '.status.conditions[]? | select(.message | test("git|repository|clone"; "i"))'
```

[TIP]
====
üí° For comprehensive sync error analysis including automated categorization, root cause detection, and detailed resource analysis, use the scripts provided in link:gitops-scripts.html[GitOps Scripts Documentation].
====

== Exercise 6: Troubleshooting Applications in Degraded State

Applications can show as "Degraded" even when synced successfully. This indicates resource-level health issues rather than sync problems.

=== Basic Degraded Resource Analysis

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
# Identify applications in degraded state
oc get applications.argoproj.io -A | grep Degraded

# Check unhealthy resources for specific application
APP_NAME="<application-name>"
APP_NS="<argocd-namespace>"

# Get overall application health
HEALTH_STATUS=$(oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.status.health.status}')
echo "Application Health Status: $HEALTH_STATUS"

# List unhealthy resources
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq -r '
  .status.resources[]? |
  select(.health.status != "Healthy" and .health.status != null) |
  "üî• \(.kind)/\(.name) (\(.namespace // "default")): \(.health.status)"'
----

=== Policy-Based Application Analysis

For applications managing OpenClusterManagement policies:

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
# Check if application manages OCM policies
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq -r '
  .status.resources[]? |
  select(.kind == "Policy" or .kind == "PolicySet") |
  "üîç Policy resource: \(.kind)/\(.name)"'

# Check policy compliance (if policies detected)
POLICY_NAMESPACE="<policy-namespace>"
oc get policies -n $POLICY_NAMESPACE -o custom-columns=NAME:.metadata.name,COMPLIANCE:.status.compliant

# Check managed cluster availability
oc get managedclusters -o custom-columns=NAME:.metadata.name,AVAILABLE:.status.conditions[0].status
----

== ArgoCD Log Analysis

For deeper troubleshooting, examine ArgoCD component logs:

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
# Check ArgoCD application controller logs for sync errors
oc logs -n openshift-gitops statefulset/openshift-gitops-application-controller --tail=100 | grep -E "(error|failed)"

# Check ArgoCD server logs for sync-related errors
oc logs -n openshift-gitops deployment/openshift-gitops-server --tail=100 | grep -E "(error|failed)"

# Check repo server logs for Git-related issues
oc logs -n openshift-gitops deployment/openshift-gitops-repo-server --tail=50 | grep -E "(error|failed)"

# Monitor logs in real-time during sync operations
oc logs -f -n openshift-gitops statefulset/openshift-gitops-application-controller | grep -i $APP_NAME
----





== Practical Must-Gather Analysis Exercises

The following exercises require analysis of actual must-gather files to apply the troubleshooting techniques learned in this lab. These exercises simulate real-world scenarios you might encounter when troubleshooting GitOps deployments.

=== Exercise A: Site-Configs Application Sync Analysis

**Scenario:** A ZTP site-configs application shows as "OutOfSync" status.

**Your Task:**
Using the provided `must-gather-file1`, analyze the site-configs application and determine:

1. **Root Cause Analysis:**
   - What specific error condition is causing the out-of-sync status?
   - Which resource type is reported as missing or failed?
   
2. **Resource Investigation:**
   - What is the name and namespace of the missing resource?
   - What resource kind/type should have been created but is missing?
   
3. **Sync History Analysis:**
   - When was the last successful sync attempt?
   - What was the last commit revision that was successfully processed?

**Approach Hints:**
- Use `oc get applications.argoproj.io` commands from the must-gather data
- Examine `.status.conditions[]` for error messages
- Check `.status.resources[]` for resource status information
- Review `.status.operationState` for sync operation details

=== Exercise B: Site-Policies Application Compliance Analysis

**Scenario:** A site-policies application managing OCM governance policies shows as "Degraded" with policy compliance issues.

**Your Task:**
Using the provided `gitops-must-gather` and `acm-must-gather` under /var/games/, analyze the site-policies application and determine:

1. **Policy Compliance Status:**
   - Which specific policies are showing as "NonCompliant"?
   - How many managed clusters are affected by the non-compliance?
   
2. **Root Cause Analysis:**
   - What are the specific violation messages for each non-compliant policy?
   - Are the violations related to missing CRDs, configuration mismatches, or resource conflicts?
   
3. **Managed Cluster Impact:**
   - Which managed clusters are reporting the policy violations?
   - Are there any managed cluster connectivity issues affecting policy enforcement?

**Approach Hints:**
- Look for Policy and PolicySet resources in the application
- Examine policy `.status.status[]` for cluster-specific compliance details
- Check replicated policies in managed cluster namespaces for detailed violation messages
- Review ManagedCluster resources for connectivity status

=== Exercise C: ArgoCD Sync History and Git Commit Correlation

**Scenario:** You need to trace the deployment history and correlate ArgoCD sync operations with specific Git commits.

**Your Task:**
Using the provided `must-gather-file2`, extract and analyze sync history to determine:

1. **Recent Sync Operations:**
   - What are the timestamps of the latest three ArgoCD sync operations?
   - What were the corresponding Git commit SHA hashes for each sync?
   
2. **Commit Analysis:**
   - Which application(s) were involved in these sync operations?
   - Were these automatic or manual sync operations?
   
3. **Deployment Tracking:**
   - Can you identify any failed or incomplete sync operations among the recent syncs?
   - What was the time interval between each of the three sync operations?

**Approach Hints:**
- Use `.status.history[]` from application objects to extract sync history
- Look for `.revision`, `.deployedAt`, and `.id` fields in sync history
- Check `.status.operationState` for sync operation details
- Examine multiple applications if necessary to get complete picture


== Additional Resources

* link:gitops-scripts.html[GitOps Troubleshooting Scripts Documentation]
* link:https://argo-cd.readthedocs.io/en/stable/[ArgoCD Official Documentation]
* link:https://docs.openshift.com/gitops/[Red Hat OpenShift GitOps Documentation]
* link:https://argo-cd.readthedocs.io/en/stable/user-guide/sync-options/[ArgoCD Sync Options and Strategies]
* link:https://argo-cd.readthedocs.io/en/stable/operator-manual/health/[ArgoCD Health Assessment]
* link:https://access.redhat.com/documentation/en-us/red_hat_openshift_gitops/[Red Hat OpenShift GitOps Troubleshooting Guide]
* link:https://docs.openshift.com/container-platform/4.15/support/gathering-cluster-data.html[OpenShift Must-Gather Documentation]
