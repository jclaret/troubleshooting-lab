= GitOps Operator - Sync Flows
include::../_attributes.adoc[]

[[gitos]]
== Lab Overview

This lab focuses specifically on ArgoCD deployment scenarios and synchronization analysis. You'll learn essential techniques for tracking git commits processed by ArgoCD, analyzing sync patterns, examining sync history, and troubleshooting sync failures with detailed error analysis.

=== Learning Objectives

By completing this lab, you will be able to:

* Check latest commits that ArgoCD has processed from Git repositories
* Determine if application syncs are performed manually or automatically
* Analyze ArgoCD application sync history and patterns
* Map ArgoCD sync operations to specific Git commits
* Investigate and resolve sync errors with detailed error message analysis
* Troubleshoot applications in degraded state and identify unhealthy resources

== Exercise 1: Tracking Latest Commits Processed by ArgoCD

=== Understanding ArgoCD Git Commit Processing

ArgoCD continuously monitors Git repositories and processes commits based on configured policies. Understanding what commits have been processed is crucial for deployment tracking.

=== Checking Latest Commits ArgoCD Has Processed

Examine the current revision and commit information processed by ArgoCD:

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
# Check current revision synced by ArgoCD for all applications
oc get applications.argoproj.io -n openshift-gitops 

# Get detailed commit information for a specific application
APP_NAME="<application-name>"
APP_NS="<argocd-namespace>"

# Extract current synced revision (commit hash)
CURRENT_REVISION=$(oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.status.sync.revision}')
echo "Current synced revision: $CURRENT_REVISION"

# Get commit details including timestamp and author
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.status.sync}' | jq '.'

# Check if there are newer commits available (target vs current revision)
TARGET_REVISION=$(oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.status.operationState.sync.revision}')
echo "Target revision: $TARGET_REVISION"
echo "Current revision: $CURRENT_REVISION"

if [ "$TARGET_REVISION" != "$CURRENT_REVISION" ]; then
    echo "‚ö†Ô∏è  Application has newer commits available for sync"
else
    echo "‚úÖ Application is synced to latest commit"
fi
----

== Exercise 2: Determining Manual vs Automatic Sync Configuration

=== Understanding ArgoCD Sync Policies

ArgoCD applications can be configured for automatic or manual synchronization. Identifying the sync policy helps understand deployment patterns.

=== Checking Sync Policy Configuration

Determine if applications are configured for manual or automatic synchronization:

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
# Check sync policy for all applications
oc get applications.argoproj.io -A -o custom-columns="NAME:.metadata.name,NAMESPACE:.metadata.namespace,AUTO_SYNC:.spec.syncPolicy.automated" --sort-by=.metadata.name

# Detailed sync policy analysis for specific application
APP_NAME="<application-name>"
APP_NS="<argocd-namespace>"

# Check if automated sync is enabled
AUTO_SYNC=$(oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.spec.syncPolicy.automated}')
if [ "$AUTO_SYNC" != "null" ] && [ -n "$AUTO_SYNC" ]; then
    echo "‚úÖ Application '$APP_NAME' has AUTOMATIC sync enabled"
    
    # Check automated sync options
    PRUNE=$(oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.spec.syncPolicy.automated.prune}')
    SELF_HEAL=$(oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.spec.syncPolicy.automated.selfHeal}')
    
    echo "  - Prune enabled: $PRUNE"
    echo "  - Self-heal enabled: $SELF_HEAL"
else
    echo "‚ö†Ô∏è  Application '$APP_NAME' has MANUAL sync only"
fi
----

== Exercise 3: ArgoCD Application Sync History Analysis

=== Understanding Sync History Importance

ArgoCD maintains detailed history of all sync operations, enabling you to track deployment patterns, investigate failures, and understand application evolution over time.

=== Examining Application Sync History

Use OpenShift commands to analyze sync history:

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
# Get historical sync information from application status
APP_NAME="<application-name>"
APP_NS="<argocd-namespace>"

# Count total number of syncs performed
SYNC_COUNT=$(oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.status.history[*]}' | jq -s '. | length')
echo "Total sync operations: $SYNC_COUNT"

# Extract sync history with timestamps
echo "=== Sync History Analysis ==="
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq -r '.status.history[] | "Sync ID: \(.id) | Deployed: \(.deployedAt) | Revision: \(.revision) | Source: \(.source.repoURL)"'

# Identify most recent syncs (last 5)
echo "=== Recent Sync Operations ==="
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq -r '.status.history[-5:] | reverse[] | "[\(.deployedAt)] Revision: \(.revision[0:8]) | Source: \(.source.path // "root")"'
----

== Exercise 4: Mapping ArgoCD Syncs to Specific Git Commits

=== Understanding Commit-to-Deployment Mapping

Mapping ArgoCD sync operations to specific Git commits is crucial for tracking which code changes have been deployed and understanding the relationship between source code and running applications.

=== Basic Commit-to-Sync Mapping

Create basic mapping between Git commits and ArgoCD deployments:

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
APP_NAME="<application-name>"
APP_NS="<argocd-namespace>"

# Get repository and revision information
REPO_URL=$(oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.spec.source.repoURL}')
CURRENT_REVISION=$(oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.status.sync.revision}')

echo "Repository: $REPO_URL"
echo "Current Deployed Commit: $CURRENT_REVISION"

# Show recent deployment history (last 5)
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq -r '
  .status.history[-5:] | reverse[] | 
  "[\(.deployedAt)] Commit: \(.revision[0:12])"'

# Check current sync and health status
SYNC_STATUS=$(oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.status.sync.status}')
HEALTH_STATUS=$(oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.status.health.status}')

echo "Current Status: Sync=$SYNC_STATUS, Health=$HEALTH_STATUS"
----

[TIP]
====
üí° For comprehensive Git-to-ArgoCD correlation analysis, use the automated script provided in link:gitops-scripts.html[GitOps Scripts Documentation].
====

== Exercise 5: Sync Error Analysis and Troubleshooting

=== Understanding ArgoCD Sync Errors

Sync errors in ArgoCD can occur due to various reasons including resource conflicts, permission issues, invalid manifests, or Git repository problems. Understanding error patterns is crucial for effective troubleshooting.

=== Basic Sync Error Investigation

Use these essential commands to identify and investigate sync errors:

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
# Identify applications with sync errors
oc get applications.argoproj.io -A -o custom-columns="NAME:.metadata.name,NAMESPACE:.metadata.namespace,SYNC:.status.sync.status,HEALTH:.status.health.status" | grep -v Synced

# Basic error analysis for specific application
APP_NAME="<application-name>"
APP_NS="<argocd-namespace>"

# Check sync status and basic conditions
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.status.sync.status}'
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.status.health.status}'

# View error conditions
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq '.status.conditions[]? | select(.type == "ComparisonError" or .type == "SyncError")'

# Check recent operation status
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq '.status.operationState | {phase, message, startedAt, finishedAt}'
----

=== Out-of-Sync Resource Analysis

Check which specific resources are causing sync issues:

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
# List out-of-sync resources
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq -r '
  .status.resources[]? |
  select(.status != "Synced") |
  "üîÑ \(.kind)/\(.name) in \(.namespace // "default"): \(.status)"'

# Check for hook execution errors
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq -r '
  .status.operationState.sync.resources[]? |
  select(.hookType != null and .status == "Failed") |
  "ü™ù Hook: \(.hookType) - \(.kind)/\(.name): \(.message)"'

# Basic comparison error check
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.status.conditions[?(@.type=="ComparisonError")].message}'
----

=== Manual Sync Actions

Basic commands for resolving sync issues:

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
# Manual sync
argocd app sync $APP_NAME

# Hard refresh (re-examine Git repository)
argocd app get $APP_NAME --hard-refresh

# Force replace resources (for immutable field changes)
argocd app sync $APP_NAME --replace

# Check ArgoCD component logs
oc logs -n openshift-gitops deployment/openshift-gitops-server --tail=50
oc logs -n openshift-gitops statefulset/openshift-gitops-application-controller --tail=50
----

=== Common Sync Error Categories

Common sync error patterns and their basic troubleshooting approaches:

**Permission Errors:**
```bash
# Check for permission-related error messages
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq '.status.conditions[]? | select(.message | test("permission|forbidden|unauthorized"; "i"))'
```

**Resource Conflicts:**
```bash
# Check for conflict errors
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq '.status.conditions[]? | select(.message | test("conflict|already exists"; "i"))'
```

**Git Repository Issues:**
```bash
# Check for Git-related errors
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq '.status.conditions[]? | select(.message | test("git|repository|clone"; "i"))'
```

[TIP]
====
üí° For comprehensive sync error analysis including automated categorization, root cause detection, and detailed resource analysis, use the scripts provided in link:gitops-scripts.html[GitOps Scripts Documentation].
====

== Exercise 6: Troubleshooting Applications in Degraded State

Applications can show as "Degraded" even when synced successfully. This indicates resource-level health issues rather than sync problems.

=== Basic Degraded Resource Analysis

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
# Identify applications in degraded state
oc get applications.argoproj.io -A -o custom-columns="NAME:.metadata.name,NAMESPACE:.metadata.namespace,SYNC:.status.sync.status,HEALTH:.status.health.status" | grep Degraded

# Check unhealthy resources for specific application
APP_NAME="<application-name>"
APP_NS="<argocd-namespace>"

# Get overall application health
HEALTH_STATUS=$(oc get applications.argoproj.io $APP_NAME -n $APP_NS -o jsonpath='{.status.health.status}')
echo "Application Health Status: $HEALTH_STATUS"

# List unhealthy resources
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq -r '
  .status.resources[]? |
  select(.health.status != "Healthy" and .health.status != null) |
  "üî• \(.kind)/\(.name) (\(.namespace // "default")): \(.health.status)"'
----

=== Policy-Based Application Analysis

For applications managing OpenClusterManagement policies:

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
# Check if application manages OCM policies
oc get applications.argoproj.io $APP_NAME -n $APP_NS -o json | jq -r '
  .status.resources[]? |
  select(.kind == "Policy" or .kind == "PolicySet") |
  "üîç Policy resource: \(.kind)/\(.name)"'

# Check policy compliance (if policies detected)
POLICY_NAMESPACE="<policy-namespace>"
oc get policies -n $POLICY_NAMESPACE -o custom-columns=NAME:.metadata.name,COMPLIANCE:.status.compliant

# Check managed cluster availability
oc get managedclusters -o custom-columns=NAME:.metadata.name,AVAILABLE:.status.conditions[0].status
----

[TIP]
====
üí° For comprehensive degraded application analysis including OCM policy troubleshooting with root cause analysis, use the scripts provided in link:gitops-scripts.html[GitOps Scripts Documentation].
====

== ArgoCD Log Analysis

For deeper troubleshooting, examine ArgoCD component logs:

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
# Check ArgoCD application controller logs for sync errors
oc logs -n openshift-gitops statefulset/openshift-gitops-application-controller --tail=100 | grep -E "(error|failed)"

# Check ArgoCD server logs for sync-related errors
oc logs -n openshift-gitops deployment/openshift-gitops-server --tail=100 | grep -E "(error|failed)"

# Check repo server logs for Git-related issues
oc logs -n openshift-gitops deployment/openshift-gitops-repo-server --tail=50 | grep -E "(error|failed)"

# Monitor logs in real-time during sync operations
oc logs -f -n openshift-gitops statefulset/openshift-gitops-application-controller | grep -i $APP_NAME
----

== Automated Troubleshooting Scripts

For comprehensive analysis and automated troubleshooting, refer to the link:gitops-scripts.html[GitOps Scripts Documentation] which provides:

* **git_argocd_correlation.sh** - Detailed Git commit to deployment correlation
* **analyze_sync_errors.sh** - Comprehensive sync error analysis with categorization
* **analyze_degraded_app.sh** - Complete degraded application analysis including OCM policy troubleshooting

== Lab Summary

This focused lab provided essential skills for ArgoCD deployment scenario analysis and sync troubleshooting. You've learned to:

* Check and track the latest commits that ArgoCD has processed from Git repositories
* Determine whether application syncs are performed manually or automatically through policy analysis
* Analyze comprehensive ArgoCD application sync history and deployment patterns
* Map ArgoCD sync operations to specific Git commits for complete deployment traceability
* Investigate and resolve sync errors through detailed error message analysis and categorization
* Troubleshoot applications in degraded state by identifying unhealthy resources and root causes

These skills are essential for maintaining reliable GitOps deployments and ensuring smooth continuous delivery workflows in production environments.

== Additional Resources

* link:gitops-scripts.html[GitOps Troubleshooting Scripts Documentation]
* link:https://argo-cd.readthedocs.io/en/stable/[ArgoCD Official Documentation]
* link:https://docs.openshift.com/gitops/[Red Hat OpenShift GitOps Documentation]
* link:https://argo-cd.readthedocs.io/en/stable/user-guide/sync-options/[ArgoCD Sync Options and Strategies]
* link:https://argo-cd.readthedocs.io/en/stable/operator-manual/health/[ArgoCD Health Assessment]
* link:https://access.redhat.com/documentation/en-us/red_hat_openshift_gitops/[Red Hat OpenShift GitOps Troubleshooting Guide]
